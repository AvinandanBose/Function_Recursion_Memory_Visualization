<h1 align="Center">𝑨.𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒊𝒕𝒔 𝑴𝒆𝒎𝒐𝒓𝒚
𝑹𝒆𝒑𝒓𝒆𝒔𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌.</h1>

<ul>
  
 <h3> <ins>𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒂 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏:</ins></h3>
   
 <h3>
   
```Syntax
   
𝒊𝒏𝒕 𝒂𝒅𝒅(𝒊𝒏𝒕 𝒑,𝒊𝒏𝒕 𝒒){
𝒊𝒏𝒕 𝒂 = 𝟏𝟎;
𝒊𝒏𝒕 𝒃 = 𝟐𝟎;
𝒓𝒆𝒕𝒖𝒓𝒏 (𝒑 − 𝒂) + (𝒒 − 𝒃);
}
   
𝒂𝒅𝒅(𝟒𝟎, 𝟓𝟎)   
   
   
```
</h3>   
  
   
<h3><ins>𝑬𝒙𝒑𝒍𝒂𝒏𝒂𝒕𝒊𝒐𝒏:</ins></h3>
   
<h3>𝑵𝒐𝒘, 𝒂𝒅𝒅(𝟒𝟎, 𝟓𝟎) 𝒊𝒔 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒂𝒍𝒍 (𝒄𝒂𝒍𝒍𝒆𝒆) 𝒕𝒉𝒂𝒕 𝒄𝒂𝒓𝒓𝒊𝒆𝒔 𝒂𝒏
𝒂𝒅𝒅𝒓𝒆𝒔𝒔. </h3>  
  
<h3>𝑨𝒏𝒅 𝒕𝒉𝒊𝒔 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒊𝒔 𝒕𝒉𝒆 𝒔𝒆𝒄𝒕𝒊𝒐𝒏 𝒘𝒉𝒆𝒓𝒆 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒓𝒆𝒕𝒖𝒓𝒏𝒊𝒏𝒈
𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆. </h3> 

<h3>𝑺𝒖𝒄𝒉 𝒂𝒅𝒅𝒓𝒆𝒔𝒔𝒆𝒔 𝒂𝒓𝒆 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔 𝒓𝒆𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔𝒆𝒔. </h3> 
 
<br>
  
<h3>𝑸) 𝑯𝒐𝒘 𝒕𝒉𝒊𝒔 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒊𝒔 𝒎𝒂𝒅𝒆? </h3> 
  
<h3><ins>𝑬𝒙𝒑𝒍𝒂𝒏𝒂𝒕𝒊𝒐𝒏:</ins></h3>
  
<h3>𝑩𝒆𝒇𝒐𝒓𝒆 𝒕𝒐 𝒔𝒕𝒂𝒓𝒕 ,𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 𝒊𝒔 𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓 𝒘𝒉𝒊𝒄𝒉 𝒉𝒐𝒍𝒅𝒔
𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒕𝒐 𝒘𝒉𝒊𝒄𝒉 𝒏𝒆𝒙𝒕 𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 𝒕𝒐 𝒃𝒆 𝒆𝒙𝒆𝒄𝒖𝒕𝒆𝒅.𝑨𝒏𝒅 𝒕𝒉𝒊𝒔
𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓 𝒊𝒔 𝒂𝒔𝒔𝒐𝒄𝒊𝒂𝒕𝒆𝒅 𝒘𝒊𝒕𝒉 𝒕𝒉𝒆 𝑪𝑷𝑼. 𝑪𝑷𝑼 𝒘𝒊𝒍𝒍 𝒑𝒖𝒔𝒉 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕
𝒗𝒂𝒍𝒖𝒆 𝒐𝒇 𝒕𝒉𝒆 𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 (𝑷𝑪) 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.
𝑨𝒏𝒅 𝒕𝒉𝒆 𝒗𝒂𝒍𝒖𝒆 𝒊𝒔 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔 `𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔`. </h3> 
  
<br>

<h2></h2> 
<h2 align="Center">𝑺𝑻𝑨𝑪𝑲 𝑭𝑹𝑨𝑴𝑬</h2>
  
  
<h3>𝑺𝒕𝒂𝒄𝒌 𝑭𝒓𝒂𝒎𝒆 𝒊𝒔 𝒎𝒂𝒊𝒏𝒍𝒚 𝒄𝒐𝒎𝒑𝒐𝒔𝒆𝒅 𝒐𝒇 ∶ 𝑭𝒓𝒂𝒎𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓,
𝑳𝒐𝒄𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏, 𝑷𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝒐𝒇 𝒕𝒉𝒆
𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏,𝑹𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏,
𝒂𝒏𝒅 𝑹𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒂𝒍𝒍𝒆𝒆. </h3>
  
<h3>𝑵𝒐𝒕𝒆 , 𝒂 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒂𝒍𝒔𝒐 𝒎𝒂𝒚 𝒉𝒂𝒗𝒆 𝒄𝒐𝒏𝒕𝒂𝒊𝒏: 𝑬𝒙𝒄𝒆𝒑𝒕𝒊𝒐𝒏 𝑯𝒂𝒏𝒅𝒍𝒊𝒏𝒈
, 𝒉𝒆𝒏𝒄𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒂𝒍𝒔𝒐 𝒄𝒐𝒏𝒕𝒂𝒊𝒏 𝒂 𝒔𝒆𝒄𝒕𝒊𝒐𝒏 𝒐𝒇
𝑬𝒙𝒄𝒆𝒑𝒕𝒊𝒐𝒏 𝑯𝒂𝒏𝒅𝒍𝒊𝒏𝒈 , 𝑩𝒖𝒇𝒇𝒆𝒓 𝒂𝒏𝒅 𝑹𝒆𝒈𝒊𝒔𝒕𝒆𝒓𝒔.
𝑩𝒖𝒕 𝒍𝒆𝒕 𝒆𝒙𝒄𝒍𝒖𝒅𝒆 𝒕𝒉𝒊𝒔 𝒕𝒉𝒊𝒏𝒈𝒔 𝒇𝒐𝒄𝒖𝒔 𝒐𝒏 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏𝒂𝒓𝒚. </h3>
  
![Screenshot (759)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/a5bfb078-e36f-445b-81a5-9fe6a6d90379)
  
<h3>𝑺𝒂𝒚, 𝑭𝒓𝒂𝒎𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒔 𝟎𝒙𝟎𝟎𝟎𝟎𝟏𝟖 𝒂𝒏𝒅 𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 𝒉𝒂𝒔
𝒗𝒂𝒍𝒖𝒆 𝒊. 𝒆. 𝒄𝒐𝒏𝒔𝒊𝒅𝒆𝒓𝒆𝒅 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒐𝒇 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒂𝒍𝒍 𝒊𝒔
𝟎𝒙𝟎𝟎𝟎𝟎𝟐𝟏. </h3>
  
<h3>  𝑵𝒐𝒘, 𝒕𝒐 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒕𝒐 𝒏𝒐𝒕𝒆 𝒐𝒇 𝒕𝒘𝒐 𝒏𝒆𝒘 𝒕𝒆𝒓𝒎𝒔:</h3>
  
<h3>  𝟏) 𝑬𝑺𝑷 (𝑬𝒙𝒕𝒆𝒏𝒅𝒆𝒅 𝑺𝒕𝒂𝒄𝒌 𝑷𝒐𝒊𝒏𝒕𝒆𝒓)𝒊𝒔 𝒂𝒏𝒐𝒕𝒉𝒆𝒓 𝒏𝒂𝒎𝒆 𝒐𝒇
𝒔𝒕𝒂𝒄𝒌 𝒑𝒐𝒊𝒏𝒕𝒆𝒓.</h3>
  
<h3>  𝟐)𝑬𝑩𝑷 𝒊. 𝒆. 𝑬𝒙𝒕𝒆𝒏𝒅𝒆𝒅 𝑩𝒂𝒔𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒂𝒏𝒐𝒕𝒉𝒆𝒓 𝒏𝒂𝒎𝒆 𝒐𝒇 𝑭𝒓𝒂𝒎𝒆
𝑷𝒐𝒊𝒏𝒕𝒆𝒓, 𝒘𝒉𝒊𝒄𝒉 𝒂𝒄𝒕 𝒂𝒔 𝒂 𝒇𝒊𝒙𝒆𝒅 𝒓𝒆𝒇𝒆𝒓𝒆𝒏𝒄𝒆 𝒑𝒐𝒊𝒏𝒕 𝒂𝒏𝒅 𝒕𝒉𝒊𝒔
𝒓𝒆𝒇𝒆𝒓𝒆𝒏𝒄𝒆 𝒑𝒐𝒊𝒏𝒕 𝒂𝒍𝒍𝒐𝒘𝒔 𝒍𝒐𝒄𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔, 𝒇𝒐𝒓𝒎𝒂𝒍 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓
𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒆𝒕𝒄. 𝒕𝒐 𝒃𝒆 𝒔𝒕𝒐𝒓𝒆𝒅 𝒘𝒊𝒕𝒉𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
  
<h3>𝑵𝒐𝒘 𝒄𝒐𝒎𝒊𝒏𝒈 𝒃𝒂𝒄𝒌 𝒕𝒐 𝒕𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒆𝒙𝒂𝒎𝒑𝒍𝒆 𝒘𝒆 𝒉𝒂𝒗𝒆 ∶  </h3>
  

![Screenshot (760)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/170851d0-3c8d-4916-b5d8-c32895c7c62d)


![Screenshot (761)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/743e6ee8-d692-4b22-8e84-84aff23e0cbd)


![Screenshot (764)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/ed5bdb15-8171-4b0b-92e1-c6861023cdef)
  
  ![Screenshot (765)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/8d2ce6a8-0c27-4ba9-bec8-10684478d60c)
  
 
<h2></h2> 
<h2 align="Center">𝑨𝒇𝒕𝒆𝒓 𝒕𝒉𝒆 𝒆𝒙𝒆𝒄𝒖𝒕𝒊𝒐𝒏 𝒐𝒇 𝒕𝒉𝒆 𝑺𝒕𝒂𝒄𝒌 𝑶𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏.</h2>
  
<ul>
  
<h3>𝟏.𝑹𝒆𝒕𝒖𝒓𝒏 𝑽𝒂𝒍𝒖𝒆 𝒂𝒏𝒅 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒇𝒓𝒐𝒎
𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝑷𝑪 (𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 )𝒘𝒊𝒍𝒍 𝒉𝒐𝒍𝒅 𝒕𝒉𝒆
𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔, 𝒘𝒉𝒊𝒄𝒉 𝒘𝒊𝒍𝒍 𝒑𝒓𝒐𝒎𝒑𝒕 𝑪𝑷𝑼 𝒕𝒉𝒂𝒕 𝒏𝒐 𝒇𝒖𝒓𝒕𝒉𝒆𝒓
𝒆𝒙𝒆𝒄𝒖𝒕𝒊𝒐𝒏 𝒊𝒔 𝒏𝒆𝒆𝒅𝒆𝒅.</h3>
  
<h3>𝟐. 𝑵𝒐 𝒔𝒐𝒐𝒏𝒆𝒓 𝒂𝒇𝒕𝒆𝒓 𝒕𝒉𝒆 𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 , 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒈𝒆𝒕𝒔
𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒇𝒐𝒓𝒎𝒂𝒍 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝒂𝒏𝒅 𝒍𝒐𝒄𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆 𝒐𝒇
𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒃𝒆𝒄𝒐𝒎𝒆 𝒊𝒏𝒗𝒂𝒍𝒊𝒅, 𝒉𝒆𝒏𝒄𝒆 𝒈𝒆𝒕𝒔 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅. </h3>
  
<h3>𝟑. 𝑻𝒉𝒆 𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒅𝒆𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 𝒐𝒄𝒄𝒖𝒓𝒔 𝒂𝒖𝒕𝒐𝒎𝒂𝒕𝒊𝒄𝒂𝒍𝒍𝒚.</h3>
  
 
</ul>  
  
  
<h2></h2>  
<h2 align="Center">𝑺𝒕𝒂𝒄𝒌 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒏 𝑨𝒅𝒅𝒕𝒊𝒐𝒏/𝑺𝒖𝒃𝒕𝒓𝒂𝒄𝒕𝒊𝒐𝒏 𝑽𝑺 𝑺𝒕𝒂𝒄𝒌 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌 𝑭𝒓𝒂𝒎𝒆.  </h2> 

<ul>
  
<h3>𝑺𝒕𝒂𝒄𝒌 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒏𝒗𝒐𝒍𝒗𝒆𝒅 𝒊𝒏 𝒔𝒕𝒂𝒏𝒅𝒂𝒓𝒅 𝒂𝒅𝒅𝒊𝒕𝒊𝒐𝒏 𝒂𝒏𝒅
𝒔𝒖𝒃𝒕𝒓𝒂𝒄𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝑺𝒕𝒂𝒄𝒌 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌 𝑭𝒓𝒂𝒎𝒆. 𝑰𝒏
𝒔𝒕𝒂𝒏𝒅𝒂𝒓𝒅 𝒂𝒅𝒅𝒊𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒔𝒖𝒃𝒕𝒓𝒂𝒄𝒕𝒊𝒐𝒏 , 𝒔𝒕𝒂𝒄𝒌 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 , 𝒘𝒉𝒊𝒄𝒉 𝒊𝒔
𝒂 𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓 𝒊𝒕𝒔𝒆𝒍𝒇 𝒑𝒐𝒊𝒏𝒕𝒔 𝒕𝒐 𝒕𝒉𝒆 𝒕𝒐𝒑 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</h3>
  
<h3>𝑾𝒉𝒆𝒓𝒆 𝒂𝒔,
𝒊𝒏 𝑺𝒕𝒂𝒄𝒌 𝑭𝒓𝒂𝒎𝒆𝒔, 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒔 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒌𝒆𝒆𝒑 𝒕𝒓𝒂𝒄𝒌
𝒐𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒐𝒓 𝒂 𝒔𝒑𝒆𝒄𝒊𝒇𝒊𝒄 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.
𝑰𝒕 𝒑𝒐𝒊𝒏𝒕𝒔 𝒕𝒐 𝒕𝒉𝒆 𝒕𝒐𝒑 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒘𝒊𝒕𝒉𝒊𝒏 𝒕𝒉𝒂𝒕 𝒇𝒓𝒂𝒎𝒆. </h3> 
  
  
</ul>  
  
</ul>


<br>
<br>
<h1></h1>
<h1 align="Center">𝑩.𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒐𝒏 𝒂𝒏𝒅 𝒊𝒕𝒔 𝑴𝒆𝒎𝒐𝒓𝒚
𝑹𝒆𝒑𝒓𝒆𝒔𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌.</h1>


<ul>

<h3>  𝟏.𝑨 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒕𝒉𝒂𝒕 𝒄𝒂𝒍𝒍𝒔 𝒊𝒕𝒔𝒆𝒍𝒇 𝒊𝒔 𝒄𝒂𝒍𝒍𝒆𝒅 𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆.</h3> 
  
<h3>  𝟐. 𝑻𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒂 𝒄𝒐𝒑𝒚 𝒐𝒇 𝒊𝒕𝒔𝒆𝒍𝒇 𝒂𝒏𝒅
𝒑𝒖𝒔𝒉 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</h3> 
  
<h3>  𝟑.𝑾𝒉𝒆𝒏 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒂 𝒄𝒐𝒑𝒚 𝒐𝒇 𝒊𝒕𝒔𝒆𝒍𝒇 𝒂𝒏𝒅
𝒑𝒖𝒔𝒉𝒆𝒔 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒑𝒐𝒑𝒔 𝒐𝒖𝒕 𝒕𝒐 𝒔𝒐𝒍𝒗𝒆𝒔 𝒕𝒉𝒆 𝒈𝒊𝒗𝒆𝒏
𝒑𝒓𝒐𝒃𝒍𝒆𝒎 𝒇𝒐𝒓 𝒘𝒉𝒊𝒄𝒉 𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒊𝒔 𝒂𝒔𝒔𝒊𝒈𝒏𝒆𝒅 ,
𝒔𝒖𝒄𝒉 𝒔𝒕𝒆𝒑𝒔 𝒂𝒓𝒆 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔 𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒔𝒕𝒆𝒑𝒔.</h3> 
  
<h3>  𝟒.𝑾𝒉𝒆𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒂𝒍𝒍𝒔 𝒊𝒕𝒔𝒆𝒍𝒇 𝒔𝒖𝒄𝒉 𝒄𝒂𝒍𝒍𝒔 𝒂𝒓𝒆 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔
𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒄𝒂𝒍𝒍𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏.</h3> 
  
<h3> 𝟓.𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒕𝒆𝒓𝒎𝒊𝒏𝒂𝒕𝒆𝒔 𝒘𝒉𝒆𝒏 𝒊𝒕 𝒓𝒆𝒂𝒄𝒉𝒆𝒔 𝒊𝒕𝒔
`𝒃𝒂𝒔𝒆` 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏.</h3> 
  

 <h2></h2> 
 <h2 align="Center"> 𝑴𝒆𝒎𝒐𝒓𝒚 𝑽𝒊𝒔𝒖𝒂𝒍𝒊𝒛𝒂𝒕𝒊𝒐𝒏
𝒐𝒇 𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏.</h2>
  
  <ul>
    
 <h3>𝑳𝒆𝒕𝒔 𝒕𝒂𝒌𝒆 𝒂𝒏 𝒆𝒙𝒂𝒎𝒑𝒍𝒆 ∶ −</h3>
    
   ![Screenshot (766)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/dd57fad2-7ff5-4e98-bd10-846d28e412c7)
    
    
  <h3>   𝒊𝒇(𝒑 == 𝟐 || 𝒒 == 𝟐) 𝒊𝒔 𝒕𝒉𝒆 𝑩𝒂𝒔𝒆 𝑪𝒂𝒔𝒆 ,
𝒘𝒉𝒆𝒓𝒆 𝒂𝒔 𝒑𝒓𝒊𝒏𝒕(𝒑 − 𝟏, 𝒒 − 𝟏) 𝒊𝒔 𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝑪𝒂𝒍𝒍.
𝑳𝒆𝒕 𝒏 = 𝟒.</h3>

    
    
<h2></h2>    
<h2 align="Center"> 𝑷𝒖𝒔𝒉 𝑶𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝒕𝒉𝒆 𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏</h2>
    
 <ul>
   
 <h3>𝑨𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒆𝒙𝒑𝒆𝒓𝒊𝒆𝒏𝒄𝒆𝒅 𝒊𝒏 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 , 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒊𝒔 
𝒄𝒓𝒆𝒂𝒕𝒆𝒅 𝒅𝒖𝒓𝒊𝒏𝒈 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒂𝒍𝒍 , 𝒅𝒖𝒓𝒊𝒏𝒈 
𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝒄𝒂𝒍𝒍 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒂 𝒄𝒐𝒑𝒚 𝒐𝒇 𝒊𝒕𝒔𝒆𝒍𝒇 𝒂𝒏𝒅 
𝒂 𝒏𝒆𝒘 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒊𝒔 𝒑𝒖𝒔𝒉𝒆𝒅 𝒂𝒃𝒐𝒗𝒆 𝒍𝒊𝒌𝒆:</h3>
   
   ![Screenshot (767)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/7ca41dd9-b16c-46e7-a28c-189bbed06d58)

   
   ![Recursion-1_Page_05](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/854e430c-1968-4200-af06-cf8cca521f64)
   
   
 <h3>  𝑨𝒔 𝒖𝒔𝒖𝒂𝒍 𝒗𝒂𝒍𝒖𝒆 𝒐𝒇 𝑷𝑪(𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓)𝒊𝒔 𝒑𝒖𝒔𝒉𝒆𝒅 
𝒊𝒏𝒔𝒊𝒅𝒆 𝒂𝒏𝒅 𝒆𝒂𝒄𝒉 𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒖𝒏𝒊𝒒𝒖𝒆 𝒇𝒐𝒓 
𝒆𝒂𝒄𝒉 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.𝑨𝒍𝒔𝒐 𝒊𝒇 𝒘𝒆 𝒔𝒆𝒆 𝑭𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 
𝒘𝒂𝒔 𝟎𝒙𝟎𝟎𝟎𝟎𝟏𝟖 𝒂𝒏𝒅 𝒏𝒐𝒘 𝟎𝒙𝟎𝟎𝟎𝟎𝟏𝑪 
𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 𝒐𝒓 𝑬𝑩𝑷 𝒊𝒔 𝟒 𝒃𝒚𝒕𝒆𝒔 𝒍𝒂𝒓𝒈𝒆𝒓 𝒕𝒉𝒂𝒏 𝒕𝒉𝒆 
𝒑𝒓𝒆𝒗𝒊𝒐𝒖𝒔 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 . 𝑨𝒏𝒅 𝑬𝒂𝒄𝒉 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒘𝒊𝒍𝒍 
𝒉𝒂𝒗𝒆 𝒖𝒏𝒊𝒒𝒖𝒆 𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓𝒔.</h3>
   
   
<h3>${(𝟎𝒙𝟎𝟎𝟎𝟎𝟎𝟏𝟖)_{𝟏𝟔} → (𝟐𝟒)_{𝟏𝟎}}$ </h3>
<h3>${(𝟎𝒙𝟎𝟎𝟎𝟎𝟎𝟏𝑪)_{𝟏𝟔} → (𝟐𝟖)_{𝟏𝟎}}$ </h3> 

   
 </h3>  

   
   
<h3>𝑸) 𝑾𝒉𝒚 𝒕𝒉𝒆 𝒏𝒆𝒙𝒕 𝑭𝒓𝒂𝒎𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒔 𝟒 𝒃𝒚𝒕𝒆𝒔?</h3>   
   
<h3> <ins>  𝑬𝒙𝒑𝒍𝒂𝒏𝒂𝒕𝒊𝒐𝒏:</ins></h3>
   
   
<h3>   𝑳𝒐𝒄𝒂𝒍 𝑽𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 ,𝑷𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝑽𝒂𝒍𝒖𝒆𝒔 𝒆𝒕𝒄. 𝒕𝒂𝒌𝒆𝒔 𝟒 𝒃𝒚𝒕𝒆𝒔 
𝒐𝒇 𝒔𝒑𝒂𝒄𝒆 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌. 𝑯𝒆𝒏𝒄𝒆 𝒘𝒆 𝒂𝒅𝒅 𝟒 𝒃𝒚𝒕𝒆𝒔 𝒕𝒐 𝒕𝒉𝒆 
𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
   
   
 ![Recursion-1_Page_06](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/afb87b7d-7db8-4c80-96ac-c212a37979e0)
   
   
 <h3>𝑵𝒆𝒙𝒕 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒘𝒊𝒍𝒍 𝒃𝒆:</h3>
   
 ![Recursion-1_Page_07](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/f81520d9-4f7c-49df-aabc-41d11bf50824)
   
 <h3>  𝑯𝒆𝒏𝒄𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒘𝒊𝒍𝒍 𝒂𝒍𝒔𝒐 𝒃𝒆 𝒊𝒏𝒄𝒓𝒆𝒂𝒔𝒆𝒅 𝟒 𝒃𝒚𝒕𝒆𝒔 
𝒍𝒐𝒏𝒈.</h3>
   
<h3> 𝑸) 𝑾𝒉𝒂𝒕 𝒊𝒔 𝑶𝒇𝒇𝒔𝒆𝒕 𝒕𝒉𝒆𝒏? </h3>   
   
   
<h3> <ins>𝑬𝒙𝒑𝒍𝒂𝒏𝒂𝒕𝒊𝒐𝒏: </ins></h3>
   
<h3> 𝑨𝒏 𝒐𝒇𝒇𝒔𝒆𝒕 𝒊𝒏 𝒂 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒊𝒔 𝒕𝒉𝒆 𝒅𝒊𝒔𝒕𝒂𝒏𝒄𝒆 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 
𝒂 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆 𝒂𝒏𝒅 𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓. 𝑰𝒇 𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 𝒊𝒔: 
${(𝟎𝒙𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖_{𝟏𝟔} = (𝟑𝟎𝟓𝟒𝟏𝟗𝟖𝟗𝟔)_{𝟏𝟎}}$ 𝒂𝒏𝒅 𝒂 𝒐𝒇𝒇𝒔𝒆𝒕 𝒐𝒇 
𝒂 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆 𝒊𝒔 𝟒 𝒕𝒉𝒆𝒏 𝒕𝒉𝒆 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆 𝒊𝒔: 
${(𝟎𝒙𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝑪)_{𝟏𝟔} = (𝟑𝟎𝟓𝟒𝟏𝟗𝟗𝟎𝟎)_{𝟏𝟎}}$ 𝒊. 𝒆. 
𝟎𝒙𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖 + 𝟒 𝒐𝒓 𝟑𝟎𝟓𝟒𝟏𝟗𝟖𝟗𝟔 + 𝟒.  </h3>
 

![Recursion-1_Page_08](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/2cb17d73-7f7d-4263-9fd0-b2d151caced0)
    
    
<h3>𝑵𝒐𝒘 𝒂𝒔 𝒕𝒉𝒆 𝒃𝒂𝒔𝒆 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏 𝒏𝒐𝒘 𝒘𝒆 𝒓𝒆𝒎𝒊𝒂𝒏 𝒘𝒊𝒕𝒉 𝒕𝒉𝒆 𝒑𝒐𝒑𝒑𝒊𝒏𝒈
𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏. </h3>
    
    
 </ul>  
 
  
  
<h2></h2>    
<h2 align="Center"> 𝑷𝒐𝒑 𝑶𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝒕𝒉𝒆 𝑹𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏</h2> 
  
   
<ul>
  
![Recursion-1_Page_10](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/cbf9f2ae-570f-44c0-8025-43e4cf6a3ec9)
  
  
  
<h3>𝟏.𝑹𝒆𝒕𝒖𝒓𝒏 𝑽𝒂𝒍𝒖𝒆 𝒂𝒏𝒅 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔 𝒈𝒆𝒕𝒔 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕.</h3>
<h3>𝟐.𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 𝒓𝒆𝒕𝒓𝒊𝒆𝒗𝒆𝒔 𝒕𝒉𝒆 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔, 𝒂𝒏𝒅
𝒑𝒖𝒔𝒉 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝒓𝒆𝒍𝒂𝒕𝒆𝒅 𝒕𝒐 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔
𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
<h3>𝟑. 𝑵𝒐𝒘 𝑭𝒓𝒂𝒎𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕𝒔 𝒔𝒖𝒃𝒕𝒓𝒂𝒄𝒕𝒆𝒅 𝒃𝒚 𝟒 𝒃𝒚𝒕𝒆𝒔.
𝒊. 𝒆. 𝟎𝒙𝟎𝟎𝟎𝟐𝟎 − 𝟒 𝒃𝒚𝒕𝒆𝒔 = 𝟎𝒙𝟎𝟎𝟎𝟎𝟏𝑪. 𝑯𝒆𝒏𝒄𝒆 𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓
𝒏𝒐𝒘 𝒑𝒐𝒊𝒏𝒕𝒔 𝒕𝒐 → 𝟎𝒙𝟎𝟎𝟎𝟎𝟏𝑪.</h3>
<h3>𝟒. 𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒈𝒆𝒕𝒔 𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒍𝒐𝒄𝒂𝒍
𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒂𝒏𝒅 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒈𝒆𝒕𝒔 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅
𝒂𝒖𝒕𝒐𝒎𝒂𝒕𝒊𝒄𝒂𝒍𝒍𝒚.</h3>
<h3>𝑺𝒊𝒎𝒊𝒍𝒂𝒓𝒍𝒚,</h3>
  
  
![Recursion-1_Page_12](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/cc2d245c-9e11-4441-b257-4c10afd6f48e)
  
  
<h3>𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒔𝒕𝒆𝒑𝒔 𝒂𝒓𝒆 𝒓𝒆𝒑𝒆𝒂𝒕𝒆𝒅:</h3>
<h3>𝟏.𝑹𝒆𝒕𝒖𝒓𝒏 𝑽𝒂𝒍𝒖𝒆 𝒂𝒏𝒅 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔 𝒈𝒆𝒕𝒔 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕.</h3>
<h3>𝟐.𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 𝒓𝒆𝒕𝒓𝒊𝒆𝒗𝒆𝒔 𝒕𝒉𝒆 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔, 𝒂𝒏𝒅
𝒑𝒖𝒔𝒉 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝒓𝒆𝒍𝒂𝒕𝒆𝒅 𝒕𝒐 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔
𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
<h3>𝟑. 𝑵𝒐𝒘 𝑭𝒓𝒂𝒎𝒆 𝑷𝒐𝒊𝒏𝒕𝒆𝒓 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕𝒔 𝒔𝒖𝒃𝒕𝒓𝒂𝒄𝒕𝒆𝒅 𝒃𝒚 𝟒 𝒃𝒚𝒕𝒆𝒔.
𝒊. 𝒆. 𝟎𝒙𝟎𝟎𝟎𝟏𝑪 − 𝟒 𝒃𝒚𝒕𝒆𝒔 = 𝟎𝒙𝟎𝟎𝟎𝟎𝟐𝟏.𝑯𝒆𝒏𝒄𝒆 𝒇𝒓𝒂𝒎𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓
𝒏𝒐𝒘 𝒑𝒐𝒊𝒏𝒕𝒔 𝒕𝒐 → 𝟎𝒙𝟎𝟎𝟎𝟎𝟐𝟏.</h3>
<h3>𝟒. 𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒈𝒆𝒕𝒔 𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒍𝒐𝒄𝒂𝒍
𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒂𝒏𝒅 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒈𝒆𝒕𝒔 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅
𝒂𝒖𝒕𝒐𝒎𝒂𝒕𝒊𝒄𝒂𝒍𝒍𝒚.</h3>
<h3>𝑺𝒊𝒎𝒊𝒍𝒂𝒓𝒍𝒚,</h3>
  
![Recursion-1_Page_14](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/96ca83b4-4f89-45bf-a1b1-0de2f008f205)

  
<h3>𝟏.𝑹𝒆𝒕𝒖𝒓𝒏 𝑽𝒂𝒍𝒖𝒆 𝒂𝒏𝒅 𝑹𝒆𝒕𝒖𝒓𝒏 𝑨𝒅𝒅𝒓𝒆𝒔𝒔 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒇𝒓𝒐𝒎
𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝑷𝑪 (𝑷𝒓𝒐𝒈𝒓𝒂𝒎 𝑪𝒐𝒖𝒏𝒕𝒆𝒓 )𝒘𝒊𝒍𝒍 𝒉𝒐𝒍𝒅 𝒕𝒉𝒆
𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔, 𝒘𝒉𝒊𝒄𝒉 𝒘𝒊𝒍𝒍 𝒑𝒓𝒐𝒎𝒑𝒕 𝑪𝑷𝑼 𝒕𝒉𝒂𝒕 𝒏𝒐 𝒇𝒖𝒓𝒕𝒉𝒆𝒓
𝒆𝒙𝒆𝒄𝒖𝒕𝒊𝒐𝒏 𝒊𝒔 𝒏𝒆𝒆𝒅𝒆𝒅.</h3>
<h3>𝟐. 𝑵𝒐 𝒔𝒐𝒐𝒏𝒆𝒓 𝒂𝒇𝒕𝒆𝒓 𝒕𝒉𝒆 𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 , 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒈𝒆𝒕𝒔
𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒇𝒐𝒓𝒎𝒂𝒍 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓 𝒂𝒏𝒅 𝒍𝒐𝒄𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆 𝒐𝒇
𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒃𝒆𝒄𝒐𝒎𝒆 𝒊𝒏𝒗𝒂𝒍𝒊𝒅, 𝒉𝒆𝒏𝒄𝒆 𝒈𝒆𝒕𝒔 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅.</h3>
<h3>𝟑. 𝑻𝒉𝒆 𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒅𝒆𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏 𝒐𝒄𝒄𝒖𝒓𝒔 𝒂𝒖𝒕𝒐𝒎𝒂𝒕𝒊𝒄𝒂𝒍𝒍𝒚.</h3>
  
  
  
  
</ul>  
    
</ul>


<br>

<br>

<h3>𝑵𝒐𝒘 𝒍𝒆𝒕𝒔 𝒄𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒂 𝒔𝒊𝒎𝒊𝒍𝒂𝒓 𝒕𝒚𝒑𝒆 𝒐𝒇
𝒓𝒆𝒈𝒖𝒍𝒂𝒓 𝒆𝒙𝒂𝒎𝒑𝒍𝒆:</h3>


<ul>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/190aab6e-284e-492d-b929-e873027e356c"  width="700" height="500">  
  

  
<h3>𝑰𝒇 𝒏 = 𝟐 , 𝒕𝒉𝒆𝒏 𝒑𝒖𝒔𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏:</h3>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/8f64717b-8645-4ddd-965c-8ebb2b6f2aba"  width="700" height="700">
  
  

<h2>𝑵𝒐𝒘,𝑷𝒐𝒑 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 ∶</h2>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/57c7f7da-8346-40dc-9529-d2416d17c02d"  width="700" height="700">  
  
  
<h2>𝑵𝒆𝒙𝒕:</h2>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/c111e7a0-d717-4be9-91ed-aa304d94859d"  width="700" height="600">   
  
<h2>𝑵𝒆𝒙𝒕:</h2>
  
  
![Screenshot (771)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/ff9d1954-d782-4bd8-b014-037d3a617e6f)



  <h2></h2>
  <h2>𝑸)𝑾𝒉𝒂𝒕 𝒄𝒐𝒖𝒕 𝒅𝒐𝒆𝒔?</h2>
  
  <ul>
    
  <h3><ins>𝑬𝒙𝒑𝒍𝒂𝒏𝒂𝒕𝒊𝒐𝒏:</ins></h3> 
    
  <h3> 𝑵𝒐𝒘 `𝒄𝒐𝒖𝒕` 𝒐𝒖𝒕𝒑𝒖𝒕 𝒅𝒂𝒕𝒂 𝒕𝒐 𝒂 𝒔𝒕𝒓𝒆𝒂𝒎,𝒊𝒕 𝒉𝒂𝒔 𝒏𝒐𝒕𝒉𝒊𝒏𝒈 𝒕𝒐 𝒅𝒐 𝒘𝒊𝒕𝒉
𝒑𝒖𝒔𝒉 𝒂𝒏𝒅 𝒑𝒐𝒑 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒐𝒇 𝒔𝒕𝒂𝒄𝒌.</h3> 
<h3> 𝑻𝒉𝒆 𝒗𝒂𝒍𝒖𝒆 𝒐𝒇 `𝒏` 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒊𝒔 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒕𝒉𝒆
𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒃𝒆𝒇𝒐𝒓𝒆 𝒊𝒕 𝒊𝒔 𝒑𝒓𝒊𝒏𝒕𝒆𝒅 .</h3> 
<h3>𝑻𝒉𝒆 𝒗𝒂𝒍𝒖𝒆 𝒐𝒇 `𝒏` 𝒘𝒊𝒍𝒍 𝒕𝒉𝒆𝒏 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒇𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌
𝒂𝒇𝒕𝒆𝒓 𝒊𝒕 𝒉𝒂𝒔 𝒃𝒆𝒆𝒏 𝒑𝒓𝒊𝒏𝒕𝒆𝒅.  </h3> 
    
    
  </ul>  
  
  
 <h2></h2> 
 <h3>𝑵𝒐𝒘 𝒄𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒂𝒏𝒐𝒕𝒉𝒆𝒓 𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆
𝒑𝒓𝒐𝒈𝒓𝒂𝒎:</h3> 
  
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/1f025a1a-7167-4914-9caf-9acbcbd2fe8d"  width="700" height="300">  
  
<h3>𝑾𝒆 𝒘𝒊𝒍𝒍 𝒔𝒕𝒂𝒓𝒕 , 𝒘𝒉𝒆𝒏 𝒕𝒉𝒆 𝒑𝒖𝒔𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊𝒔 𝒄𝒐𝒎𝒑𝒍𝒆𝒕𝒆𝒅
𝒂𝒏𝒅 𝒕𝒉𝒆 𝒃𝒂𝒔𝒆 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏 𝒊𝒔 𝒆𝒙𝒆𝒄𝒖𝒕𝒆𝒅.</h3> 
<h3>𝑻𝒉𝒆 `𝟏` 𝒐𝒇 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒔𝒉𝒆𝒅 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 , 𝒂𝒔 𝒔𝒉𝒐𝒘𝒏
𝒃𝒆𝒍𝒐𝒘:</h3> 
  
  
![Recursion-2_Page_07](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/ed02d3c6-069d-4aa4-b58f-94cfddfb0075)
  

<h3>𝑵𝒆𝒙𝒕 𝒕𝒉𝒆 𝒃𝒂𝒔𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 `𝟏` 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒂𝒅𝒅𝒆𝒅 𝒘𝒊𝒕𝒉 `𝟏` 𝒂𝒏𝒅 𝒓𝒆𝒔𝒖𝒍𝒕
𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒔𝒉𝒆𝒅 𝒕𝒐 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝒔𝒆𝒄𝒕𝒊𝒐𝒏.</h3>
  
  
![Recursion-2_Page_08](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/4d8c31cb-a66b-47aa-b77d-abd649415bc8)
  
<h3>𝑨𝒏𝒅 𝒕𝒉𝒆 𝒑𝒓𝒐𝒄𝒆𝒔𝒔 𝒊𝒔 𝒄𝒐𝒏𝒕𝒊𝒏𝒖𝒆𝒅 𝒕𝒊𝒍𝒍 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊𝒔
𝒏𝒐𝒕 𝒇𝒊𝒏𝒊𝒔𝒉𝒆𝒅 𝒂𝒔 𝒔𝒉𝒐𝒘𝒏 𝒃𝒆𝒍𝒐𝒘:</h3>
  
  ![Recursion-2_Page_09](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/088faf77-4311-44b0-acda-a3d7f7a80377)
  
![Recursion-2_Page_10](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/d5647739-4985-40a2-b927-69f30f3ec95f)
  
 
  
</ul>  

<h2></h2>
<h2 align="Center">𝑴𝒂𝒊𝒏 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝑺𝒕𝒂𝒄𝒌 𝑭𝒓𝒂𝒎𝒆</h2>

<ul>
  
  
<h3>𝟏. 𝑻𝒉𝒆𝒓𝒆 𝒂𝒓𝒆 𝒕𝒘𝒐 𝒌𝒊𝒏𝒅 𝒐𝒇 𝒔𝒄𝒆𝒏𝒂𝒓𝒊𝒐𝒔 ∶</h3>
  
<ul>
  
<h3>𝒂) 𝒆𝒊𝒕𝒉𝒆𝒓 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒊𝒔 𝒄𝒂𝒍𝒍𝒆𝒅 𝒊𝒏 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒘𝒊𝒕𝒉𝒐𝒖𝒕 𝒃𝒆𝒊𝒏𝒈
𝒂𝒔𝒔𝒊𝒈𝒏𝒆𝒅 𝒕𝒐 𝒂𝒏𝒚 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆.</h3>
<h3>𝒃)𝒆𝒊𝒕𝒉𝒆𝒓 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒊𝒔 𝒄𝒂𝒍𝒍𝒆𝒅 𝒊𝒏 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏
𝒂𝒔𝒔𝒊𝒈𝒏𝒆𝒅 𝒕𝒐 𝒂𝒏𝒚 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆.</h3>

 
</ul> 
  
<h3>𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒕𝒉𝒆 𝒇𝒐𝒍𝒍𝒐𝒘𝒊𝒏𝒈 𝒆𝒙𝒂𝒎𝒑𝒍𝒆: </h3>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/a01424a5-27f1-4cc1-b9fb-f4addc4fa953"  width="700" height="500">   
  

<h3>  𝑺𝒂𝒚 𝒏 = 𝟑.</h3>
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/956d6b2a-38a6-41a4-9aa0-e3a34f494d8e"  width="300" height="500">   
  
 
  
  
  


<h3> 𝑻𝒉𝒆 𝒓𝒆𝒔𝒖𝒍𝒕 𝒈𝒆𝒕𝒔 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒇𝒓𝒐𝒎 𝒑𝒓𝒊𝒏𝒕() 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒔𝒕𝒂𝒄𝒌
𝒇𝒓𝒂𝒎𝒆 𝒊𝒔 𝟑.𝑹𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝟑 𝒈𝒆𝒕𝒔 𝒔𝒕𝒐𝒓𝒆𝒅 𝒊𝒏 𝑬𝑨𝑿 𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓
𝒄𝒐𝒏𝒏𝒆𝒄𝒕𝒆𝒅 𝒘𝒊𝒕𝒉 𝑴𝒊𝒄𝒓𝒐𝒑𝒓𝒐𝒄𝒆𝒔𝒔𝒐𝒓. </h3>
  


  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/76543705-b0a2-408a-8bf6-05caf0251094"  width="200" height="100">   
    
<h3>𝑬𝑨𝑿 𝒊. 𝒆.𝑬𝒙𝒕𝒆𝒏𝒅𝒆𝒅 𝑨𝒄𝒄𝒖𝒎𝒖𝒍𝒂𝒕𝒐𝒓 𝒐𝒇 𝑴𝒊𝒄𝒓𝒐𝒑𝒓𝒐𝒄𝒆𝒔𝒔𝒐𝒓,
𝒘𝒉𝒊𝒄𝒉 𝒊𝒔 𝒊𝒕𝒔𝒆𝒍𝒇 𝒂 𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓.</h3>
  
<h3>𝑵𝒐𝒘 𝒇𝒓𝒐𝒎 𝑬𝑨𝑿 𝒓𝒆𝒈𝒊𝒔𝒕𝒆𝒓 , 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝟑 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒖𝒔𝒉𝒆𝒅 𝒕𝒐 𝒎𝒂𝒊𝒏
𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
  
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/c51b6458-f71b-4db1-aa83-9fc488c8a891"  width="700" height="500">    
  

<h3> 𝑻𝒉𝒊𝒔 𝒑𝒓𝒐𝒄𝒆𝒔𝒔 𝒓𝒆𝒎𝒂𝒊𝒏 𝒔𝒂𝒎𝒆 𝒇𝒐𝒓 𝒊𝒏𝒕 𝒂 = 𝒑𝒓𝒊𝒏𝒕(𝒏), 𝒂𝒔 𝒔𝒉𝒐𝒘𝒏
𝒃𝒆𝒍𝒐𝒘:</h3>
  
  
![Screenshot (776)](https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/3b87d064-ec65-41be-810a-c25fb15d72d2)
  
  
<h3> 𝑰𝒏 𝒔𝒂𝒎𝒆 𝒘𝒂𝒚 𝒄𝒊𝒏 𝒊𝒔 𝒔𝒕𝒂𝒏𝒅𝒂𝒓𝒅 𝒊𝒏𝒑𝒖𝒕 𝒇𝒓𝒐𝒎 𝒊𝒏𝒑𝒖𝒕 𝒅𝒆𝒗𝒊𝒄𝒆 𝒂𝒏𝒅
𝒉𝒂𝒔 𝒏𝒐𝒕𝒉𝒊𝒏𝒈 𝒕𝒐 𝒅𝒐 𝒘𝒊𝒕𝒉 𝒅𝒊𝒓𝒆𝒄𝒕𝒍𝒚 𝒇𝒐𝒓 𝒔𝒕𝒂𝒄𝒌 𝒃𝒖𝒕 𝒂𝒔 𝒊𝒕 𝒕𝒂𝒌𝒆
𝒊𝒏𝒑𝒖𝒕 𝒇𝒐𝒓 𝒂 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆, 𝒕𝒉𝒆 𝒊𝒏𝒑𝒖𝒕 𝒗𝒂𝒍𝒖𝒆 𝒈𝒆𝒕𝒔 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌 .</h3>
  
<h3>𝑵𝒐𝒘 𝒂𝒔 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆 𝒈𝒆𝒕𝒔 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒊. 𝒆. 𝟑,𝑷𝒓𝒐𝒈𝒓𝒂𝒎
𝑪𝒐𝒖𝒏𝒕𝒆𝒓(𝑷𝑪)𝒊𝒔 𝒖𝒑𝒅𝒂𝒕𝒆𝒅 𝒘𝒊𝒕𝒉 𝒓𝒆𝒕𝒖𝒓𝒏 𝒂𝒅𝒅𝒓𝒆𝒔𝒔
𝒐𝒇 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏: 𝟎𝒙𝟏𝟐𝟑𝟒𝟓𝟔.</h3>
  
  
<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/ee2cfdd1-40e0-4198-8c34-85141063be90"  width="700" height="700">   
  

<h3>𝑨𝒏𝒅 𝒍𝒊𝒌𝒆 𝒐𝒕𝒉𝒆𝒓 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏′𝒔 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 , 𝒕𝒉𝒆 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏′𝒔 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒂𝒍𝒔𝒐 𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒔 𝒂𝒏𝒅 𝒍𝒐𝒄𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔 𝒈𝒆𝒕𝒔 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅 𝒂𝒖𝒕𝒐𝒎𝒂𝒕𝒊𝒄𝒂𝒍𝒍𝒚 .</h3>
 

  
  
</ul> 

<br>

<br>

<h3>𝑵𝒐𝒘 𝒂𝒇𝒕𝒆𝒓 𝒘𝒓𝒂𝒑𝒑𝒊𝒏𝒈 𝒖𝒑 𝒕𝒉𝒆 𝒘𝒉𝒐𝒍𝒆 𝒑𝒓𝒐𝒄𝒆𝒔𝒔, 𝒂𝒏𝒅
𝒇𝒓𝒂𝒎𝒊𝒏𝒈 𝒊𝒕 𝒊𝒔 𝒂 𝒍𝒊𝒕𝒕𝒍𝒆 𝒅𝒊𝒇𝒇𝒊𝒄𝒖𝒍𝒕 𝒂𝒏𝒅 𝒂 𝒃𝒊𝒕 𝒍𝒆𝒏𝒈𝒕𝒉𝒚.</h3>

<h3>𝑯𝒆𝒏𝒄𝒆 𝒕𝒂𝒌𝒆 𝒕𝒉𝒐𝒔𝒆 𝒆𝒙𝒂𝒎𝒑𝒍𝒆𝒔 𝒂𝒈𝒂𝒊𝒏:</h3>


<h2></h2>
<h2 align="Center"><ins>𝑬𝒙𝒂𝒎𝒑𝒍𝒆:𝟏</ins></h2>

<ul>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/7d66e99e-5fcb-49ce-9389-502e90d3cdc9"  width="700" height="600">  


</ul>

<h3>𝑾𝒆 𝒄𝒂𝒏 𝒔𝒊𝒎𝒑𝒍𝒊𝒇𝒚 𝒕𝒉𝒆 𝒔𝒕𝒆𝒑𝒔 𝒍𝒊𝒌𝒆:𝒏 = 𝟒</h3>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/8ce23f32-48e5-4462-802e-fa54f76d77a6"  width="500" height="400">  


<h3>𝑵𝒐𝒕𝒆, 𝒉𝒐𝒘 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒆𝒙𝒄𝒖𝒕𝒆𝒅?</h3>

<h3 align="Center"><ins>𝟏𝒔𝒕 𝑷𝒂𝒓𝒕</ins></h3>

<ul>
  
<h3>𝟏𝒔𝒕 𝒏 = 𝟒 𝒂𝒏𝒅 𝒏 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒎𝒂𝒊𝒏 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆.</h3>
<h3>𝟐𝒏𝒅 𝒑 = 𝟒 𝒂𝒏𝒅 𝒒 = 𝟒 𝒂𝒏𝒅 𝒑, 𝒒 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌.</h3>
<h3>𝟑𝒓𝒅 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒄𝒉𝒆𝒄𝒌 𝒑 = 𝟐 𝒐𝒓 𝒒 = 𝟐 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒐𝒓 𝒇𝒂𝒍𝒔𝒆 , 𝒏𝒐𝒘 𝒊𝒕 𝒊𝒔
𝒇𝒂𝒍𝒔𝒆.</h3>
<h3>𝟒𝒓𝒕𝒉 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒈𝒐 𝒕𝒐 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕 𝒂𝒏𝒅 𝒑𝒓𝒊𝒏𝒕 𝒂 𝒂𝒏𝒅 𝒃 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆.</h3>
<h3>𝟓𝒕𝒉 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝒊. 𝒆. 𝒄𝒂𝒍𝒍 𝒑𝒓𝒊𝒏𝒕 (𝟒 − 𝟏 = 𝟑, 𝟒 − 𝟏 = 𝟑)
𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆𝒍𝒚.</h3>

</ul>

<h3 align="Center"><ins>𝟐𝒏𝒅 𝑷𝒂𝒓𝒕</ins></h3>

<ul>
  
<h3>𝟏𝒔𝒕 𝒑 = 𝟑 𝒂𝒏𝒅 𝒒 = 𝟑 𝒂𝒏𝒅 𝒑, 𝒒 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌.</h3>
<h3>𝟐𝒏𝒅 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒄𝒉𝒆𝒄𝒌 𝒑 = 𝟐 𝒐𝒓 𝒒 = 𝟐 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒐𝒓 𝒇𝒂𝒍𝒔𝒆 , 𝒏𝒐𝒘 𝒊𝒕 𝒊𝒔
𝒇𝒂𝒍𝒔𝒆.</h3>
<h3>𝟑𝒓𝒅 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒈𝒐 𝒕𝒐 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕 𝒂𝒏𝒅 𝒑𝒓𝒊𝒏𝒕 𝒂 𝒂𝒏𝒅 𝒃 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆.</h3>
<h3>𝟒𝒓𝒕𝒉 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝒊. 𝒆. 𝒄𝒂𝒍𝒍 𝒑𝒓𝒊𝒏𝒕 (𝟑 − 𝟏 = 𝟐, 𝟑 − 𝟏 = 𝟐)
𝒓𝒆𝒄𝒖𝒓𝒔𝒊𝒗𝒆𝒍𝒚.</h3>

</ul>

<h3 align="Center"><ins>𝑳𝒂𝒔𝒕 𝑷𝒂𝒓𝒕</ins></h3>

<ul>

<h3>𝑨𝒔 𝒊𝒕 𝒄𝒂𝒍𝒍𝒔 𝒑𝒓𝒊𝒏𝒕(𝒑 = 𝟐, 𝒒 = 𝟐), 𝒑, 𝒒 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏 𝒕𝒉𝒆
𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒂𝒏𝒅 𝒕𝒉𝒆𝒏 𝒘𝒊𝒍𝒍 𝒄𝒉𝒆𝒄𝒌 𝒑 = 𝟐 𝒐𝒓 𝒒 = 𝟐 𝒊𝒔 𝒕𝒓𝒖𝒆
𝒐𝒓 𝒇𝒂𝒍𝒔𝒆 , 𝒏𝒐𝒘 𝒊𝒕 𝒊𝒔 𝒕𝒓𝒖𝒆 , 𝒉𝒆𝒏𝒄𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝟐.𝑨𝒔 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒏𝒐𝒕 𝒈𝒐 𝒕𝒐
𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕 𝒉𝒆𝒏𝒄𝒆 𝒏𝒐 `𝒄𝒐𝒖𝒕` 𝒔𝒕𝒂𝒕𝒆𝒎𝒆𝒏𝒕 𝒓𝒖𝒏𝒔.</h3>

</ul>

<br>
<br>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/b58f1c2c-3f31-400a-9446-66b8841a5b7d"  width="400" height="400"> 

<h3>𝟐 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒕𝒐 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒇𝒓𝒐𝒎 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒐𝒓 𝒎𝒂𝒊𝒏 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏′𝒔 𝒔𝒕𝒂𝒄𝒌 𝒇𝒓𝒂𝒎𝒆 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒂𝒈𝒂𝒊𝒏 𝒈𝒆𝒕
𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒔𝒐 𝒕𝒉𝒂𝒕 𝒘𝒆 𝒄𝒂𝒏 𝒔𝒆𝒆 𝒕𝒉𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒗𝒂𝒍𝒖𝒆.</h3>








</ul> 


<h2></h2>

<h2 align="Center"><ins>𝟐𝒏𝒅 𝑬𝒙𝒂𝒎𝒑𝒍𝒆:</ins></h2>

<ul>


<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/58044378-4591-4395-9e51-503b12fa0a16"  width="700" height="600">  

<h3>𝒍𝒆𝒕,𝒏 =  𝟒</h3>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/76691a0b-e393-44e2-9492-49419c8cd06c"  width="500" height="600"> 

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/c429eac2-99e9-4a2f-b114-c07e9fdec311"  width="500" height="600"> 






</ul>

<h2></h2>
<h2 align="Center"><ins>𝟑𝒓𝒅 𝑬𝒙𝒂𝒎𝒑𝒍𝒆:</ins></h2>

<ul>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/f52141cc-a156-4c70-b40c-30884cb2a29d"  width="700" height="600">

<h3>𝒍𝒆𝒕,𝒏 =  𝟒</h3>

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/f0a62190-c8e5-4141-81d1-f6dd0da3cd62"  width="400" height="500"> 

<img src="https://github.com/AvinandanBose/Function_Recursion_Memory_Visualization/assets/38869235/e646f993-fd6b-4ab8-a559-a54796175732"  width="400" height="500"> 


</ul>

</ul>

<h1 align="Center">***********</h1>
